# Qt 国际化与本地化

## 概述

Qt 提供了完整的国际化（i18n）和本地化（l10n）支持，包括文本翻译、数字/日期/货币格式化、从右到左（RTL）布局等功能。本文档涵盖 Qt 国际化的核心概念和面试常见问题。

---

## 1. 翻译系统基础

### 1.1 tr() 函数

```cpp
// tr() 是 QObject 的成员函数，用于标记可翻译字符串
class MyWidget : public QWidget {
    Q_OBJECT
public:
    MyWidget() {
        // 基本用法
        setWindowTitle(tr("Main Window"));

        // 带参数的翻译
        QString msg = tr("Hello, %1!").arg(userName);

        // 带复数形式
        QString items = tr("%n item(s) selected", "", count);
        // count=1: "1 item selected"
        // count=5: "5 items selected"

        // 带注释帮助翻译者理解上下文
        QString action = tr("Open", "Menu action to open a file");
    }
};
```

### 1.2 QT_TR_NOOP 和 QT_TRANSLATE_NOOP

```cpp
// 标记字符串以便 lupdate 提取，但不立即翻译
// 用于静态数组或初始化列表

// QT_TR_NOOP - 在当前类上下文
static const char* colors[] = {
    QT_TR_NOOP("Red"),
    QT_TR_NOOP("Green"),
    QT_TR_NOOP("Blue")
};

// 使用时翻译
for (const char* color : colors) {
    comboBox->addItem(tr(color));
}

// QT_TRANSLATE_NOOP - 指定上下文
static const char* messages[] = {
    QT_TRANSLATE_NOOP("ErrorMessages", "File not found"),
    QT_TRANSLATE_NOOP("ErrorMessages", "Access denied")
};

// 使用时翻译
QString translated = QCoreApplication::translate("ErrorMessages", messages[0]);
```

### 1.3 非 QObject 类中的翻译

```cpp
// 方法1：使用 Q_DECLARE_TR_FUNCTIONS
class MyClass {
    Q_DECLARE_TR_FUNCTIONS(MyClass)
public:
    QString getMessage() {
        return tr("Hello World");  // 现在可以使用 tr()
    }
};

// 方法2：使用 QCoreApplication::translate
class AnotherClass {
public:
    QString getMessage() {
        return QCoreApplication::translate("AnotherClass", "Hello World");
    }
};

// 方法3：使用 QObject::tr (静态调用)
QString msg = QObject::tr("Hello World");
```

---

## 2. 翻译文件工作流

### 2.1 .pro 文件配置

```qmake
# 指定翻译文件
TRANSLATIONS = \
    translations/app_zh_CN.ts \
    translations/app_ja_JP.ts \
    translations/app_de_DE.ts

# 可选：指定 lupdate 的额外选项
LUPDATE_OPTIONS = -no-obsolete
```

### 2.2 CMake 配置

```cmake
find_package(Qt6 REQUIRED COMPONENTS LinguistTools)

# 设置翻译源文件
set(TS_FILES
    translations/app_zh_CN.ts
    translations/app_ja_JP.ts
)

# 创建翻译目标
qt_add_translations(myapp
    TS_FILES ${TS_FILES}
    QM_FILES_OUTPUT_VARIABLE QM_FILES
)

# 或者手动控制
qt_create_translation(QM_FILES ${CMAKE_SOURCE_DIR}/src ${TS_FILES})
qt_add_translation(QM_FILES ${TS_FILES})
```

### 2.3 工作流程

```bash
# 1. 提取可翻译字符串到 .ts 文件
lupdate myproject.pro
# 或
lupdate src/ -ts translations/app_zh_CN.ts

# 2. 使用 Qt Linguist 编辑 .ts 文件
linguist translations/app_zh_CN.ts

# 3. 编译 .ts 文件为 .qm 二进制文件
lrelease myproject.pro
# 或
lrelease translations/app_zh_CN.ts -qm translations/app_zh_CN.qm
```

### 2.4 .ts 文件格式

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.1" language="zh_CN">
<context>
    <name>MainWindow</name>
    <message>
        <location filename="../src/mainwindow.cpp" line="42"/>
        <source>File</source>
        <translation>文件</translation>
    </message>
    <message numerus="yes">
        <location filename="../src/mainwindow.cpp" line="58"/>
        <source>%n file(s) selected</source>
        <translation>
            <numerusform>选中了 %n 个文件</numerusform>
        </translation>
    </message>
</context>
</TS>
```

---

## 3. 加载和切换翻译

### 3.1 基本加载

```cpp
int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    // 加载 Qt 内置翻译（对话框按钮等）
    QTranslator qtTranslator;
    if (qtTranslator.load(QLocale::system(),
                          "qt", "_",
                          QLibraryInfo::path(QLibraryInfo::TranslationsPath))) {
        app.installTranslator(&qtTranslator);
    }

    // 加载应用程序翻译
    QTranslator appTranslator;
    if (appTranslator.load(QLocale::system(),
                           "app", "_",
                           ":/translations")) {
        app.installTranslator(&appTranslator);
    }

    MainWindow w;
    w.show();
    return app.exec();
}
```

### 3.2 运行时切换语言

```cpp
class MainWindow : public QMainWindow {
    Q_OBJECT
public:
    MainWindow() {
        createLanguageMenu();
    }

private slots:
    void switchLanguage(const QString& locale) {
        // 移除旧翻译器
        if (m_translator) {
            qApp->removeTranslator(m_translator);
            delete m_translator;
        }

        // 加载新翻译
        m_translator = new QTranslator(this);
        if (m_translator->load(QString("app_%1").arg(locale), ":/translations")) {
            qApp->installTranslator(m_translator);
        }

        // 重新翻译 UI
        retranslateUi();
    }

    void retranslateUi() {
        // 重新设置所有可见文本
        setWindowTitle(tr("Main Window"));
        m_fileMenu->setTitle(tr("&File"));
        m_openAction->setText(tr("&Open"));
        m_saveAction->setText(tr("&Save"));
        // ...
    }

private:
    void createLanguageMenu() {
        QMenu* langMenu = menuBar()->addMenu(tr("Language"));

        QActionGroup* langGroup = new QActionGroup(this);
        langGroup->setExclusive(true);

        QAction* enAction = langMenu->addAction("English");
        enAction->setData("en");
        enAction->setCheckable(true);
        langGroup->addAction(enAction);

        QAction* zhAction = langMenu->addAction("中文");
        zhAction->setData("zh_CN");
        zhAction->setCheckable(true);
        langGroup->addAction(zhAction);

        connect(langGroup, &QActionGroup::triggered,
                [this](QAction* action) {
                    switchLanguage(action->data().toString());
                });
    }

    QTranslator* m_translator = nullptr;
    QMenu* m_fileMenu;
    QAction* m_openAction;
    QAction* m_saveAction;
};
```

### 3.3 使用 QEvent::LanguageChange

```cpp
class MyWidget : public QWidget {
protected:
    void changeEvent(QEvent* event) override {
        if (event->type() == QEvent::LanguageChange) {
            // 当翻译器改变时自动调用
            retranslateUi();
        }
        QWidget::changeEvent(event);
    }

private:
    void retranslateUi() {
        m_label->setText(tr("Hello"));
        m_button->setText(tr("Click Me"));
    }
};
```

---

## 4. 区域设置和格式化

### 4.1 QLocale 基础

```cpp
// 获取系统区域设置
QLocale systemLocale = QLocale::system();
qDebug() << "System locale:" << systemLocale.name();  // e.g., "zh_CN"

// 创建特定区域设置
QLocale chinese(QLocale::Chinese, QLocale::China);
QLocale german(QLocale::German, QLocale::Germany);

// 设置默认区域设置
QLocale::setDefault(QLocale(QLocale::Chinese, QLocale::China));
```

### 4.2 数字格式化

```cpp
QLocale locale(QLocale::German);

// 数字格式化
double value = 1234567.89;
QString formatted = locale.toString(value, 'f', 2);
// 结果: "1.234.567,89" (德国格式用点分隔千位，逗号分隔小数)

// 解析数字
bool ok;
double parsed = locale.toDouble("1.234.567,89", &ok);

// 货币格式化
QString currency = locale.toCurrencyString(1234.56);
// 结果: "1.234,56 €"

// 百分比
QString percent = locale.toString(0.1234, 'f', 2) + locale.percent();
```

### 4.3 日期时间格式化

```cpp
QLocale locale(QLocale::Chinese, QLocale::China);
QDateTime now = QDateTime::currentDateTime();
QDate today = QDate::currentDate();
QTime currentTime = QTime::currentTime();

// 预定义格式
QString shortDate = locale.toString(today, QLocale::ShortFormat);
// "2024/1/15"
QString longDate = locale.toString(today, QLocale::LongFormat);
// "2024年1月15日"

// 自定义格式
QString custom = locale.toString(now, "yyyy年MM月dd日 HH:mm:ss");
// "2024年01月15日 14:30:00"

// 时间格式
QString time = locale.toString(currentTime, QLocale::ShortFormat);

// 相对日期（Qt 6.6+）
// QString relative = locale.toString(today, QLocale::RelativeDate);
```

### 4.4 其他格式化

```cpp
QLocale locale;

// 星期几
QString dayName = locale.dayName(1);           // "Monday" 或 "星期一"
QString shortDay = locale.dayName(1, QLocale::ShortFormat);  // "Mon" 或 "周一"

// 月份名
QString monthName = locale.monthName(1);       // "January" 或 "一月"

// 文本方向
Qt::LayoutDirection dir = locale.textDirection();
// 对于阿拉伯语、希伯来语等返回 Qt::RightToLeft

// 测量系统
QLocale::MeasurementSystem system = locale.measurementSystem();
// QLocale::MetricSystem 或 QLocale::ImperialUSSystem
```

---

## 5. 从右到左（RTL）布局支持

### 5.1 检测和设置布局方向

```cpp
// 检测应用程序布局方向
if (QApplication::layoutDirection() == Qt::RightToLeft) {
    // 当前是 RTL 布局
}

// 设置应用程序布局方向
QApplication::setLayoutDirection(Qt::RightToLeft);

// 根据语言自动设置
QLocale locale(QLocale::Arabic);
if (locale.textDirection() == Qt::RightToLeft) {
    QApplication::setLayoutDirection(Qt::RightToLeft);
}
```

### 5.2 镜像布局

```cpp
class RtlAwareWidget : public QWidget {
public:
    RtlAwareWidget() {
        QHBoxLayout* layout = new QHBoxLayout(this);

        // 布局会自动镜像
        // LTR: [Icon] [Label] [Spacer] [Button]
        // RTL: [Button] [Spacer] [Label] [Icon]
        layout->addWidget(new QLabel("Icon"));
        layout->addWidget(new QLabel("Label"));
        layout->addStretch();
        layout->addWidget(new QPushButton("Action"));
    }

protected:
    void paintEvent(QPaintEvent*) override {
        QPainter painter(this);

        // 绘制时考虑布局方向
        if (layoutDirection() == Qt::RightToLeft) {
            // 绘制镜像内容
            painter.scale(-1, 1);
            painter.translate(-width(), 0);
        }

        // 正常绘制代码...
    }
};
```

### 5.3 QSS 中的 RTL 支持

```css
/* 使用方向感知的属性 */
QWidget {
    /* 使用 start/end 而不是 left/right */
    margin-start: 10px;  /* Qt 6+ */
    margin-end: 5px;

    /* 或使用传统方式配合选择器 */
    padding-left: 10px;
}

/* RTL 特定样式 */
QWidget[layoutDirection="RightToLeft"] {
    padding-left: 5px;
    padding-right: 10px;
}
```

---

## 6. 编码和 Unicode

### 6.1 QString 和 Unicode

```cpp
// QString 内部使用 UTF-16
QString str = "Hello 世界";  // 自动从 UTF-8 字面量转换

// 从不同编码创建
QByteArray latin1Data = "Hello";
QString fromLatin1 = QString::fromLatin1(latin1Data);

QByteArray utf8Data = "你好";
QString fromUtf8 = QString::fromUtf8(utf8Data);

// 转换为不同编码
QByteArray toUtf8 = str.toUtf8();
QByteArray toLatin1 = str.toLatin1();  // 非 Latin-1 字符会丢失
QByteArray toLocal = str.toLocal8Bit();
```

### 6.2 QTextCodec（Qt 5）/ QStringConverter（Qt 6）

```cpp
// Qt 6 方式
#include <QStringConverter>

// 编码
QStringEncoder encoder(QStringConverter::Utf8);
QByteArray encoded = encoder.encode("Hello 世界");

// 解码
QStringDecoder decoder(QStringConverter::Utf8);
QString decoded = decoder.decode(encoded);

// 检测编码
auto encoding = QStringConverter::encodingForData(someData);
if (encoding) {
    QStringDecoder autoDecoder(*encoding);
    QString text = autoDecoder.decode(someData);
}
```

### 6.3 文件 IO 编码

```cpp
// 读取指定编码的文件
QFile file("data.txt");
if (file.open(QIODevice::ReadOnly)) {
    QTextStream stream(&file);
    stream.setEncoding(QStringConverter::Utf8);  // Qt 6
    // stream.setCodec("UTF-8");  // Qt 5

    QString content = stream.readAll();
}

// 写入指定编码
QFile outFile("output.txt");
if (outFile.open(QIODevice::WriteOnly)) {
    QTextStream stream(&outFile);
    stream.setEncoding(QStringConverter::Utf8);
    stream.setGenerateByteOrderMark(true);  // 添加 BOM

    stream << "Hello 世界" << Qt::endl;
}
```

---

## 7. 动态翻译和高级技巧

### 7.1 翻译上下文消歧

```cpp
// 同一源字符串在不同上下文中可能有不同翻译
class FileMenu : public QMenu {
    Q_OBJECT
public:
    FileMenu() {
        // 上下文是 "FileMenu"
        addAction(tr("Open"));  // 翻译为"打开"
    }
};

class DoorController : public QObject {
    Q_OBJECT
public:
    void openDoor() {
        // 上下文是 "DoorController"
        emit statusChanged(tr("Open"));  // 翻译为"开启"
    }
};
```

### 7.2 带标记的复杂翻译

```cpp
// 处理包含标记的字符串
QString html = tr("<b>%1</b> items found in <i>%2</i>")
    .arg(count)
    .arg(folder);

// 翻译者可以重排参数顺序
// 日语可能翻译为: "<i>%2</i> で <b>%1</b> 件見つかりました"
```

### 7.3 复数形式

```cpp
// 不同语言有不同的复数规则
// 英语: 1 vs many
// 俄语: 1, 2-4, 5-20, 21, 22-24, ...
// 阿拉伯语: 0, 1, 2, 3-10, 11-99, 100+

QString message = tr("%n file(s)", "", fileCount);

// .ts 文件中的复数翻译（俄语示例）
/*
<message numerus="yes">
    <source>%n file(s)</source>
    <translation>
        <numerusform>%n файл</numerusform>      // 1, 21, 31, ...
        <numerusform>%n файла</numerusform>     // 2-4, 22-24, ...
        <numerusform>%n файлов</numerusform>    // 0, 5-20, 25-30, ...
    </translation>
</message>
*/
```

### 7.4 嵌入式翻译（资源文件）

```cpp
// 在 .qrc 文件中嵌入翻译
/*
<qresource prefix="/translations">
    <file>app_zh_CN.qm</file>
    <file>app_ja_JP.qm</file>
</qresource>
*/

// 从资源加载
QTranslator translator;
if (translator.load(":/translations/app_zh_CN.qm")) {
    qApp->installTranslator(&translator);
}
```

---

## 8. 最佳实践

### 8.1 可翻译性准则

```cpp
// DO: 使用完整句子
QString msg = tr("The file %1 was saved successfully.").arg(filename);

// DON'T: 拼接字符串片段
QString msg = tr("The file ") + filename + tr(" was saved successfully.");
// 原因：不同语言的语序不同

// DO: 为翻译者提供上下文
QString action = tr("Open", "file menu");
QString state = tr("Open", "door state");

// DO: 使用 arg() 处理变量
QString msg = tr("Page %1 of %2").arg(current).arg(total);

// DON'T: 在翻译中包含变量
QString msg = tr("Page " + QString::number(current));  // 错误！
```

### 8.2 代码组织

```cpp
// 集中管理翻译字符串（可选）
namespace Strings {
    inline QString fileNotFound() {
        return QCoreApplication::translate("Errors", "File not found");
    }
    inline QString accessDenied() {
        return QCoreApplication::translate("Errors", "Access denied");
    }
}

// 使用
showError(Strings::fileNotFound());
```

### 8.3 测试翻译

```cpp
// 伪翻译测试：检测未翻译字符串
class PseudoTranslator : public QTranslator {
public:
    QString translate(const char* context, const char* sourceText,
                      const char* disambiguation, int n) const override {
        Q_UNUSED(context)
        Q_UNUSED(disambiguation)
        Q_UNUSED(n)
        // 添加标记以便识别未翻译文本
        return QString("[%1]").arg(sourceText);
    }
};

// 在调试构建中使用
#ifdef QT_DEBUG
    PseudoTranslator* pseudo = new PseudoTranslator;
    app.installTranslator(pseudo);
#endif
```

---

## 面试常见问题

### Q1: tr() 和 QCoreApplication::translate() 的区别？

**答案**：
- `tr()` 是 QObject 的成员函数，自动使用当前类名作为翻译上下文
- `translate()` 是静态函数，需要显式指定上下文
- `tr()` 只能在 QObject 子类或使用 Q_DECLARE_TR_FUNCTIONS 的类中使用
- `translate()` 可以在任何地方使用

```cpp
// tr() 等效于:
QString text = tr("Hello");
QString text = QCoreApplication::translate("ClassName", "Hello");
```

### Q2: 如何实现运行时语言切换？

**答案**：
1. 移除当前翻译器：`qApp->removeTranslator(translator)`
2. 加载新翻译文件到翻译器
3. 安装新翻译器：`qApp->installTranslator(translator)`
4. 调用 `retranslateUi()` 或响应 `QEvent::LanguageChange` 更新 UI

### Q3: lupdate 和 lrelease 的作用？

**答案**：
- `lupdate`：扫描源代码，提取 tr() 等标记的字符串，生成或更新 .ts 文件
- `lrelease`：将 .ts 文件（XML 格式）编译为 .qm 文件（二进制格式）用于运行时加载

### Q4: QT_TR_NOOP 的用途？

**答案**：用于标记字符串以便 lupdate 提取，但不立即翻译。典型场景：
- 静态数组初始化
- 延迟翻译的字符串表
- 需要在运行时根据条件翻译的字符串

```cpp
static const char* items[] = { QT_TR_NOOP("Apple"), QT_TR_NOOP("Orange") };
// 使用时: tr(items[index])
```

### Q5: 如何处理复数形式？

**答案**：
```cpp
QString msg = tr("%n item(s)", "", count);
```
- 翻译者在 .ts 文件中为每种复数形式提供翻译
- Qt 根据数量和语言规则自动选择正确形式
- 不同语言有不同的复数规则（英语2种，俄语3种，阿拉伯语6种）

### Q6: QString 内部使用什么编码？

**答案**：QString 内部使用 UTF-16 编码。每个 QChar 是 16 位，可以存储 BMP（基本多文种平面）字符。对于 BMP 外的字符（如某些表情符号），使用代理对（surrogate pairs）表示。

### Q7: 如何支持从右到左语言？

**答案**：
1. 使用 `QApplication::setLayoutDirection(Qt::RightToLeft)`
2. 布局管理器会自动镜像
3. 使用 `QLocale::textDirection()` 检测语言方向
4. 避免硬编码 left/right，使用布局感知的方法
5. 在 QSS 中使用方向感知的属性

---

## 总结

Qt 国际化关键点：

| 概念 | 说明 |
|------|------|
| tr() | 标记可翻译字符串，QObject 成员函数 |
| QTranslator | 加载和应用翻译文件 |
| .ts 文件 | XML 格式的翻译源文件 |
| .qm 文件 | 二进制格式的翻译文件，运行时使用 |
| lupdate | 提取源代码中的字符串到 .ts |
| lrelease | 编译 .ts 为 .qm |
| QLocale | 区域设置，格式化数字/日期/货币 |
| RTL | 从右到左布局支持 |

国际化最佳实践：
1. 所有用户可见文本使用 tr()
2. 使用完整句子，不要拼接字符串片段
3. 使用 arg() 处理变量，允许翻译者重排顺序
4. 为歧义字符串提供上下文注释
5. 处理复数形式
6. 测试 RTL 布局
7. 使用伪翻译检测遗漏
